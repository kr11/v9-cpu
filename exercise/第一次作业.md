# 第一次作业
2015311965 康荣
## lab1
### 任务要求：
支持时钟，中断，输出
###实现细节：
在lab1中，输出实现较简单：

```
//输入参数为port和val，首先LL将寄存器a设置为port，将寄存器b设为参数2（即待输入字符），然后利用BOUT命令向标准输出端输出一个字符。

out(port, val)  { asm(LL,8); asm(LBL,16); asm(BOUT); }
```	    
为了实验输出效果，因此在此基础上实现了输出字符串函数：

```
//用到了out函数；字符串起点为*p，输出n个字符
sys_write(fd, char *p, n) { int i; for (i=0; i<n; i++) out(fd, p[i]); return i; }

```

为实现时钟中断的效果，首先利用TIME命令设置timeout时间以触发时间中断：

```
stmr(int val)   { asm(LL,8); asm(TIME); }
```
设置中断时的操作：

```
//中断时保存所有寄存器数据，然后切换到内存态，执行trap()函数，然后恢复各寄存器值，中断返回（RTI）
alltraps()
{
  asm(PSHA);
  asm(PSHB);
  asm(PSHC);
  asm(LUSP);
  asm(PSHA);
  trap();
  asm(POPA);
  asm(SUSP);
  asm(POPC);
  asm(POPB);
  asm(POPA);
  asm(RTI);
}
```
实现trap函数，即向屏幕输出字符串“ticks”

```
trap(int *sp, int c, int b, int a, int fc, unsigned *pc)
{
  switch (fc) {
  case FTIMER + USER:
    if (ticks % 20000 == 0) {
        sys_write(1, "ticks\n", 6);  
    }
    break;  
  default:
    default: sys_write(1, "panic! unknown interrupt\n", 25); asm(HALT);  
  }
}
```

然后在主函数中调用中断函数：

```
stmr(1000);
//中断调用函数
ivec(alltraps);
```
实验效果即在屏幕上定时输出ticks。

代码及注释详见os_lab1.c。
## lab2
### 任务要求：
支持建立页表
###实现细节：
本部分代码主要参考os2.c，但是只提取了setup_page部分，由于中断部分已经实现在lab1，因此在此处去掉。

首先实现一些函数：

```
//a=参数value，然后设置页目录表起始地址为a，在调用时传入的参数为pg_dir，在setup_paging中赋值
pdir(value)     { asm(LL,8); asm(PDIR); }
//设置页机制(使能或禁止)
spage(value)    { asm(LL,8); asm(SPAG); }
//停止
halt(value)     { asm(LL,8); asm(HALT); }
```
在main函数中做一些准备工作：

```
//内核部分地址4M，因此页表从4MB开始，首先赋值寄存器a
asm(LI, 4*1024*1024); 
//sp指针指向a(4M)
asm(SSP); 
```

然后实现setup_paging函数：

```
setup_paging()
{
  int i;
  //设置页表的初始地址
  pg_dir = (int *)((((int)&pg_mem) + 4095) & -4096);
  //分四页，每页1024*4个字节，即4KB
  pg0 = pg_dir + 1024;
  pg1 = pg0 + 1024;
  pg2 = pg1 + 1024;
  pg3 = pg2 + 1024;
  //将一级页表参数设为可用
  pg_dir[0] = (int)pg0 | PTE_P | PTE_W | PTE_U;  // identity map 16M
  pg_dir[1] = (int)pg1 | PTE_P | PTE_W | PTE_U;
  pg_dir[2] = (int)pg2 | PTE_P | PTE_W | PTE_U;
  pg_dir[3] = (int)pg3 | PTE_P | PTE_W | PTE_U;
  //一个物理内存块是4KB，页表初始地址管理四个页块，而pg0是从pg_dir+1024开始的，因此把4~1024这部分赋值为0
  for (i=4;i<1024;i++) pg_dir[i] = 0;
  //初始化四个页面。每个页起初都是可用的，又因为一个4KB页为2^12，因此页块的物理地址低12位都是0，用于存储页的状态（PTE_P | PTE_W | PTE_U），将所有二级页表参数设为可用。
  for (i=0;i<4096;i++) pg0[i] = (i<<12) | PTE_P | PTE_W | PTE_U;  // trick to write all 4 contiguous pages
  //页起始地址设置
  pdir(pg_dir);
  //设置页机制(使能)
  spage(1);
}
```


代码及注释详见os_lab2.c。