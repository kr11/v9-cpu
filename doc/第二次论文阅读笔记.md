# 第二次论文研读
<center>康荣 2015311965</center>
## Mars Code
Curiosity火箭在火星表面着陆，火箭的运行和控制都是由软件来完成的，本文介绍了JPL团队为提高软件可靠性采取的措施。

```
火箭在地球上重900kg，在火星上重337.5kg。
注：这是一个非常低级的错误，我想它表述的是:
On Earth, Curiosity weighed 9000 N.
On Mars, Curiosity weighed no more than 3375 N.
```

### 项目难度：

本次代码量超过了以往的代码综合，任何小的错误都可能带来重大损失；因此，为了降低风险，我们采取了一些预防措施，如模块化，数据隐藏，基于接口的开发和故障保护机制；在开发工序上，保持良好的开发过程，如需求清晰化，需求跟踪，版本整合，严格的单元测试和集成测试等等；没有一种方法能够杜绝所有错误，但是我们可以采取一些标准来尽量减少出错的可能。

首先，影响航天任务的大多数任务异常都已经经过了仔细研究和记录，大部分信息可以获取到。以此为基础，我们对各种问题的根本原因进行分类。包括：

- 基本的代码编写和设计错误（多任务处理的不规范使用等）
- 动态内存分配的错误使用等等

由此我们制定了代码编写标准。相比于其他，他仅包含关于风险的规则，而没有代码风格的规定（我们认为这可以用工具解决）对于将哪些规则纳入到码编写新标准中,我们采用了两大准则：

- 其一,规则必须与我们从之前任务中观察到的风险直接关联;
- 其二,规则本身必须能够通过工具进行验证。

#### Level 1
最低工艺标准：1.所有代码必须符合语言规范：

1. 不能依赖超过该语言定义本身的特定编译器拓展；（飞行软阿金采用的是ISO-C99）
2. 素有代码可以通过便与其和源码分析器的考验，不能有任何警告（此项检测中，所有的警告都会启用）

#### Level 2
Loc-2旨在确保嵌入式系统上下文的可预测执行。所有循环在可执行迭代数量上必须有上限。

#### Level 3
LoC-3与断言使用相关。最初的标准是代码数超过十行的所有函数必须包含一个以上的断言，后来改为2%。证据表明，淡烟密度越高，残漏的缺陷密度越低。MSL的代码中的断言比例达到了2.26%，远高于其他软件。

#### Level 4
所有`任务关键性代码`的目标级别。该标准限制对`C预处理程序、指针`的使用.
#### 更高
对`安全关键型`软件，采用Loc-5和6级别。

另外，我们还引入了新的飞行软件开发人员认证计划，即对开发人员的检验和考试。

### 基于工具的代码审核

规则并不能避免所有错误，同行之间的代码审核必不可少。同行审核在识别设计缺陷上很好，但是检测是否符合规则、避免常见的编写错误等就要开静态源码分析器了。不同的分析器令人惊讶的是，输出结果迥异而鲜有重叠，因此我们在所有代码运行四个分析器。（Coverity，Codesonar，Semmle和Uno）

### 模型检查
MSL的任务许多都使用了多线程，竞争不可避免，我们广泛采用了逻辑模型检查器Spin，以及C代码模型提取工具的一个拓展版本。

我们分析了MSL任务的多个关键组件，如双CPU引导控制算法(该算法决定两个CPU中的哪一个将在引导阶段控制航天器)、非易失性闪存文件系统,以及数据管理子系统。通过这些分析识别可以在任务启动之前从将错误代码剔除,有效地帮助降低飞行过程中发生意外事件的几率。

要手动证明一种并发算法在所有可能的执行条件下都是正确的，可能太过困难。Lamport后来在CAL 中形式化了原始算法，其表明可以通过模型检查器更加快速地找出那些问题。模型提取器还可以免去手动构建形式化模型的需要，使我们能够在数分钟内对多线程代码片段执行这类验证，而不需要几天时间。

我们通过两个示例说明MSL任务中是如何应用软件冗余的。第一个示例强调了在整个代码中使用断言。断言始终都要得到满足，这意味着严格来说，对它的评估几乎始终是冗余的。但有时它的确会发生，例如外部条件的变化无法预见时。断言的价值在于能在执行中尽早检测出非正常状况，使得故障保护监控程序可以采取措施预防损害。
软件冗余的第二个示例用于保护关键的着陆序列。这是任务中唯一同时使用主CPU和其备份的阶段(备份处于热待机状态)。如果在两个CPU上并行运行相同的着陆软件，那么就几乎无法提供保护。因此，我们开发了两个版本的”进入至降落与着陆“代码，主CPU上运行的是主版本，备份CPU上运行的是简化版。如果在着陆序列中主CPU发生意外,备份CPU被设定为自动接管，可按照简化的过程继续执行该序列。该版本本是“冗余”的,因为它从未被调 用执行。

## The Scalable Commutativity Rule: Designing Scalable Software for Multicore Processors
### 1 引言
我们引入了下列规则︰

```
任何接口间的通信都可以以可拓展的方式实现。
Whenever interface operations commute, they can be implemented in a way that scales.
```
该规则可以帮助开发者构建具有伸缩性的软件，从界面设计、实现、测试和评价。同时提出了叫COMMUTER的模型工具。

现在评估可拓展性都实现则一个工作量，测试在核数量变化的情况下性能变化。但是测不出真实瓶颈。

本文不再从硬件的角度，而是从软件接口的层次来所以优化。
### 2 可拓展交互原则
这部分解决两个问题呢，是什么，为什么。我们用一种基于抽象行为、历史记录和实现的形式化规则。这种正则化依赖SIM可交互性，它界定了复杂软件接口的规则可用性。一个系统执行过程叫做一个"history"，例如：
H=ABCACBDDEEFGHFHG
各个进程都是调用和响应的一一对应。操作交互的时候结果事不依赖顺序的。可拓展性被认为是实现属性而不是接口属性。

考虑Unix系统调用。很少有人无条件地在每个状态和历史记录之间通讯 ，但有很多有条件下通信，基于状态和参数等。

### 3 Analyzing interfaces using COMMUTER
作者使用COMMUTER工具来作为指导ScaleFS。

COMMUTER工具采用带界面的模型，确定通讯的精确条件，它可以在进程中继承，用来推动最初的设计和实施，逐步改善现有的实现，或帮助开发人员了解接口。

用户用Python表示接口的符号化模型。接口符号模型用COMMUTER的分析器ANALYZER组件生成表达式的参数和状态。这些表达式可以直接检查状态，或者传递到TESTGEN，把这些条件变成真正的测试用例。
### 4 evaluation

实验部分原文采用了一张图，比较ramfs和ScaleFS。ScaleFS的冲突数量有了明显的减少。

### 5 Conclusion
>交互接口设计原则：

1. 将复合操作分解（即每个操作只应做一件事）。例如，'fork' 操作将分别创建新的进程和快照状态和当前进程的属性。这种组合意味着它不能与其他几个操作交互。
2. 采用规范非决定论。允许自由的实现。例如，允许 'open' 返回任何未使用的文件描述符，而不是一个最低可用的值。
3. 允许弱顺序。例如，许多系统命令即使在使用数据报的消息的时候，也会发送通过本地Unix域套接字。在“多writer和多reader”模式下，允许收发之间的交互将提供更好的性能。
4. 以异步方式释放资源。许多有全局影响的POSIX在操作返回之前必须是可见的。这一般情况下是好的设计，但比起释放资源来说，这需要更加严格、高消耗和更好的保障机制。
 
 






