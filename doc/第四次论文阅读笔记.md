#第四次论文研读
<center>2015311965 康荣</center>
## mTCP: A Highly Scalable User-level TCP Stack for Multicore Systems

mTCP 是一个的用户级别的 TCP 堆栈，用于多核处理器的系统。mTCP 从 I/O 包到 TCP 连接管理上进行全方位的优化。

![](http://i3.piimg.com/cf9d3cb546f4a335.png)


## Limitations of the Kernel’s TCP Stack

Linux尽管在多方面做出了优化，但显得仍然不够，尤其是针对于短连接的tcp。如果tcp过短，每次只有几十个字节，那么建立连接和释放连接所带来的开销会占据明显的比例。

同时，linux存在一些并发的不足，导致了多核不能很好地并行工作，因此在IO方面无法发挥多核优势，例如文件描述符是共享的，这就存在一方调用多方等待的闲置，同时，由于在启动了IO处理线程之后，网卡再收到消息，自身却不知道应该发送到那个核上，这就出现了同一份程序的资源调用和执行要分布在不同的核上，跨多核之间交互消耗很大。

同时，在系统调用方面（System call overhead）也有优化空间。现在的BSD套接字API需要频繁的状态切换。以及其他一些操作（连接的建立，断开等等）出现后必须要产生中断，从用户态切换到内核态，处理，再返回。这样的切换和其他的系统调用很耗资源。

linux有两个态user和kernel，这样的隔离有助于系统安全，但会阻碍批处理的执行。
网络层的port是用来区分进程的，但port是共享资源，整个内存里只有一份，多核竞争来抢，就会出现并行化问题。

基于以上问题，本文实现了将TCP协议栈放到了用户态中，节省了大量中断和状态切换的时间，提高了性能。
## mCTP：User-level TCP Stack

mTCP中的affinity-accept部分，能够实现收到一个包之后，能送到相应的core上。这样就解决了当初的一个重要问题：同一份网络任务，却不在同一个core上执行。

在mTCP中，消息的发送、接受都是在用户态，只要读到port即可，各核之间平衡良好。mTCP不再采用中断、切换状态的方式来建立、取消连接，因此极大地提升了性能。

但同时应该注意，中断自有中断的好处。中断是一种主动机制，当有IO消息时才会触发，这样可以保证平时释放CPU资源，不会一直繁忙。但是修改了机制之后，CPU必须主动地去轮询是否有新的消息传来并获取到自己的core上，而不是kernel来中断并告诉他，这样使得CPU一致处在繁忙状态上，造成能耗上升。但是本文、或者说更多的文章中，性能远比能耗重要。

同时，mTCP中将mTCP和app分开两个线程，两者之间实现更大程度上的并发。

## Application Programming Interface
本文还花了较多的篇幅来说明自己实现的api接口。本文尽量不去改动linux 内核，同时实现了尽量全面的api接口，但最终还是改了一些代码，使得易用性和可拓展性受到影响。

## Conclusion
mTCP是一个用户级别的高性能TCP堆栈设计。他针对于多核做出了优化。作者发现linux内核在CPU使用上，尽管做出了优化，但仍然不够，尤其是针对于短连接的tcp。mTCP对linux内核实现的TCP堆栈进行了优化，这对于TCP（网络层）之上的应用层和传输层都带来了极大的效率提高。他对于频繁发送的消息进行了批处理和缓存，同时尽量提高单核的操作效率。

最后，本文证明了mTCP将现有的应用最多提高到320%，这是一个很可观的数字。

mTCP：不修改内核而只是修改了TCP协议栈，虽然性能很好，但是没有广泛应用的原因在于：首先，mTCP还是改了一定的接口，这对于向下兼容有一定困难；同时，TCP/IP的协议栈非常完整，但是作者的这些研究人员还没有经历来完成一个非常完善、而且很完整的协议栈。