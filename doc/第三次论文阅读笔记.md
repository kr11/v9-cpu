# 第三次论文研读
<center>康荣 2015311965</center>
## Non-scalable locks are dangerous
对于我们平常提到的原子指令（比如test_and_set），只要是对于一个共享变量的原子指令，都会涉及到cache invalidation，即要把其它核的cache line都invalidate，这就是造成在多核环境下scalability上不去的原因，因为过多的原子指令将会造成in-flight的message太多（这个也是那篇Non-scalable locks are dangerous强调的问题）。因此在同步原语中要想获得高的scalability，就必须减少对共享变量的原子操作（其实在ReEmu中它的目的也正是如此）。

### Read-Write Lock

读写锁，顾名思义，就是将读锁和写锁分开来处理，对于读锁，它可以允许多个读者同时对一个共享变量进行读取，但是需要维护一个全局counter来记录读者的数量。当某个核产生一个写的请求，那么就不能再允许有新的读者进入critical section（CS），而写者也需要所有读者结束（即counter降为0）后才可以进入写的CS。在这里，一般的实现方式是这样的：

```
Read object begin
  P(object.lock)
  AtomicAdd(object.activeReader, 1)
  V(object.lock)
  Do Actual Read
  AtomicAdd(object.activeReaders, −1)
end
Write object begin
  P(object.lock)
  while object.activeReaders != 0 do delay
  Do Actual Write
  V(object.lock)
end
```
这里值得注意的是，虽然它减小了读者和读者之间信号量（P/V）的竞争，但是读者在读之前需要对共享变量activeReader进行原子加，安装前面所说的，这就会造成cache line invalidate message数量的增加，不具有很好的可扩展性。

## Scalable Kernel TCP Design and Implementation for Short-Lived Connections
由于飞速增长的带宽，CPU核数的增加，本文提出了一种新的，适应于短连接的、可拓展的TCP栈：Fastsocket，一种兼容BSD-socket的设计.

这个问题的主要来源在于，当前带宽渐增，网速渐增，每次传输的数据量也渐增，但是每次连接时间却很短（如微博），因此，快速的建立和终止连接就变得很重要。同时，由于核数增加，socket的可拓展性变得越发重要。**这里可以看到，还是核数的问题**

在理想情况下，单次连接的所有操作都在单CPU上完成，这样可以非常充分的发挥并行性。（可惜现在的linux上是有不同CPU完成的）

TCB负责连接建立断开。同时，一个连接的TCB在两阶段被更新：

1. 当CPU收到一个MIC中断，并传出了一个packet的时候；
2. 用户态的其他擦做以及执行CPU得到了输出packet准备向外发送的时候。

VFS抽象了一个socket，并向用户级别应用输出了一个socket（FD）。因此VFS在开关FD时候的开销极大地影响了connect的建立。

因此，socket性能瓶颈主要关注两点：TCB management and VFS abstraction。本文提出了Fastsocket，向后兼容的结局了socket的可拓展性和兼容性问题，建立可一个高可拓展性的kernel框架。（*对于当前的网络环境，向后兼容无疑是新技术投入应用最重要的需求*）





